# Python loops

We will begin by importing a standard set of Python modules that we need. This is a typical list. It's expedient to load often used modules by giving them a shorter alias. NP is the community standard for NumPy, PD for pandas. We also load this simple commander entity interface to matplotlib, pyplots, and finally, we ask the Jupyter notebook to keep the plots that we make in the notebook itself instead of opening a different window.

So, how exactly do loops work in Python? We see them in a concrete example. Consider the combinatorial problem of breaking a U.S. dollar into all possible combinations of coins. For instance, $1 coin, two half-dollar coins, one half-dollar coins and two quarters, and so on. You can already see how we're going to need several nested loops for this. The basic structure of a loop in Python is for variable in iterable followed by a block that is executing multiple times with the variable that can own the values provided by the iterable.

But what is an iterable? We can think of it as a black box that keeps providing new values until it runs out. A simple example is a Python container such as a list or a dict. Perhaps the most important iterable is range, which provides integer value from a start to a stop, exclusive of the stop. That means that range zero 10 counts from zero to nine. There are many reasons for this convention about the end value. For instance, by looking at the end value, we see immediately that the total number of elements in the range is 10. In the end, however, we just have to accept this as one of the building assumptions of Python.

Range has a couple more interesting features. We can omit the start value, and then it's assumed to be zero. We can provide a step argument to move through the range in increments larger than one. And if I give the step, I must also give the initial value to avoid confusion. Notice that the step is the third argument.

Let's go back to the dollar. To generate all possible ways to break it up, we will use a very simple minder strategy. We will consider all possible candidate combinations, including the zero to one $1 coins, zero to two half-dollar coins, zero to four quarters, and so on. And at the end for each, we will check whether it adds up to a dollar. Therefore we need six nested loops.

A loop within a loop within a loop. Luckily, it's Python that will keep track of them. This means that the first loop will be over range two. So, looping over zero and one. To keep the maximum number of each coin inside, we'll write it as range(1+1). We then proceed with the other coins, one loop for each. Each nested loop is indented with respect to its parent. Inside the innermost loop, we will check whether the total amount is $1. If so, we will add this combination to a list called combinations, which will start that.

It turns out there are 293 ways to get a dollar in change. That's a solution to the problem we posed. However, in data analysis, it often happens that the solution raises a new question. For instance, how many ways to make $2 out of change or three? Does the number of combinations increase linearly or quadratically with the amount we're breaking up?

What we need to do, then, is to take the code we wrote and generalize it to answer those questions. Creating a function, we'll call it, say, find combinations, that will take a dollar amount in cents and return all possible ways to do it. Before we do so, we make a couple of changes to our code to make it faster and to make it easier to generalize. This is an example of refactoring. The first change is that we will not loop by count, but by value, using the step argument of the range. For instance, instead of looping over quarters with count 25 between zero and four, we will loop over the amount from zero to 100 in steps of 25. So, I have rewritten all the loops in these terms. As you see, the end of the range is always a dollar, 100 cents plus one. So the dollar is included. And the step is 100 for $1, 50 for half dollar, 25 for the quarter, and so on.

The second change we're making is that we don't actually need the innermost loop over the pennies. As long as the total up to that point is less or equal than a dollar, we can always make up the difference. Therefore, we compute the dollar and write a different test. The result is again the same. Now we can take our code and turn it into the function find_combinations by replacing the value 100 with a variable argument. We'll call it total. We do need to indent our code to make up the body of the function.

You may be curious to know how fast this number grows. A plot will give us an idea. So let's plot 100 through 500, and we use a comprehension, which we will explain later, to find a corresponding number of combinations. Matplotlib will give us a quick plot. In fact, the number grows approximately as the fifth power of the total. You will find the loops are everywhere in data analysis, so it's good to get familiar with them. In Python, you can do a lot with the for construct and with range.

![alt]([https://link](https://raw.githubusercontent.com/diablinux/jupyter-notebooks-collection/master/data-structures/loops/combinations_plot.png))